## 编辑距离

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/edit-distance
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。





## 方法一：自顶向下递归

### 思路：

看到题之后没有具体思路，但还是看到关键词 **最少操作数**，往动态规划问题上面想；其实题目已经提示了，三种操作：增、删、改；这不就是动态规划里面三个选择吗，那状态有啥？肯定两个指针分别遍历两个单词，然后比较每个字母呗，所以状态无非就两种：相等还是不相等；那对于 dp 函数我们就有了目标：它要帮助我们决定相等的时候干啥，不相等的时候干啥：

- 如果相等：那肯定是不需要操作了，直接拿递归前的那个结果就行，如果我们定义 dp 函数为 **`word1` 的前 `i` 个字母换成 `word2` 的前 `j` 个字母所用的最小操作数**，那么如果 `word1[i]` 和 `word2[j]`是相等的，那肯定 `dp(i,j)` 和 `dp(i-1, j-1)`相等呗，因为相等就啥都不用干啊
- 如果不相等：直接就照抄题里给的提示呗：
  1. 替换：这个是最好想的，既然替换了，那就相当于 `i` 和 `j`都动一下，不用纠结谁换谁了，反正这个位置上我调节好了，咱们直接往下走，`dp(i-1, j-1)`
  2. 插入：假如说我们要把 `word1` 换成 `word2`，那 `i` 在 `word1` 里面遍历着呢，这时候我们决定要插入一个，那是不是就相当于我们满足了 `j` 所指的这个字母了，那 `j` 是不是就该往下继续走了，然后`i`还在原地呢？因为你插入了啥，`i`不用看，所以 `dp(i, j-1)`
  3. 删除：类似上面的插入，这里 `i` 依旧在遍历，但发现自己得删一下，你 `i`删不删，和我 `j` 有啥关系，所以 `j` 就不变，`i` 自己动：`dp(i-1, j)`
- 那为什么动的时候是 `i - 1` 和 `j - 1` 啊？因为我们是 **从单词的末尾开始指的，慢慢往前比较**

这时候想一下，**四要素还缺啥？现在有了状态，选择，dp函数，是不是还差 base case？**该怎么找，归纳呗，怎么控制我们递归不无限循环？看一下边界在那里。这里起点平平无奇，从末尾开始，那终点呢？假如说 `i` 和 `j` 有一个已经完成了遍历，但另一个还没完呢，这时候会发生什么？没办法，谁叫你弹药少呢，别人子弹没打完，剩多少你挨多少吧，如果 `i` 完了， `j` 没完，那你再来 `j+1` 次，反之。这里之所以是 `j+1` 而不是 `j`，原因是我们 base case 的状态是 **当 `i` 或 `j` 等于 -1 时**，毕竟它们俩都是索引嘛，所以 0 才是第一个字母，-1 才算超



### 暴力解法：

```python
def minDistance(s1: str, s2: str):
    def dp(i, j):
        if i == -1:
            return j + 1
        if j == -1:
            return i + 1

        if s1[i] == s2[j]:
            return dp(i-1, j-1)
        else:
            # get the shortest path
            return min(
                dp(i, j-1) + 1,  # add
                dp(i-1, j) + 1,  # delete
                dp(i-1, j-1) + 1  # replace
            )
    return dp(len(s1) - 1, len(s2) - 1)
```

### 

### 过程优化：

就在这里面是存在重叠子问题的，怎么看？因为我们从 `dp(i,j)`可以直接到 `dp(i-1,j-1)`，也就是替换；也可以先删除到`dp(i-1,j)`再增加到`dp(i-1,j-1)`

优化的方法无非就是添加一个字典 memo 记录下曾经走过的路，所以我们可以直接在递归的开始检查一下字典，是否存在这条路，有的话就直接取值，没有的话再自己走：

```python
def minDistance(s1: str, s2: str):
    memo = {}
    def dp(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        if i == -1:
            return j + 1
        if j == -1:
            return i + 1

        if s1[i] == s2[j]:
            memo[(i, j)] = dp(i-1, j-1)
        else:
            # get the shortest path
            memo[(i, j)] = min(
                dp(i, j-1) + 1,  # add
                dp(i-1, j) + 1,  # delete
                dp(i-1, j-1) + 1  # replace
            )
        return memo[(i, j)]
    return dp(len(s1) - 1, len(s2) - 1)
```



## 方法二：自底向上迭代

便于理解先以 s1 = execution，s2 = intention 来举例，谁换成谁步骤数量都一样，只不过是行和列的不同：

|      | null |  i   |  n   |  t   |  e   |  n   |  t   |  i   |  o   |  n   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| null |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
|  e   |  1   |  1   |  2   |  3   |  3   |  4   |  5   |  6   |  7   |  8   |
|  x   |  2   |  2   |  2   |  3   |  4   |  4   |  5   |  6   |  7   |  8   |
|  e   |  3   |  3   |  3   |  3   |  3   |  4   |  5   |  6   |  7   |  8   |
|  c   |  4   |  4   |  4   |  4   |  4   |  4   |  5   |  6   |  7   |  8   |
|  u   |  5   |  5   |  5   |  5   |  5   |  5   |  5   |  6   |  7   |  8   |
|  t   |  6   |  6   |  6   |  5   |  6   |  6   |  5   |  6   |  7   |  8   |
|  i   |  7   |  6   |  7   |  6   |  6   |  7   |  6   |  5   |  6   |  7   |
|  o   |  8   |  7   |  7   |  7   |  7   |  7   |  7   |  6   |  5   |  6   |
|  n   |  9   |  8   |  7   |  8   |  8   |  7   |  8   |  7   |  6   |  5   |

想法就很简单了，相比之前的

最长公共子序列问题

这里我们先别管俩字母相同不相同，首先看第一列和第一行，很常规的升序，因为不管哪个单词跟空字符串来比，都是它本身的长度，这就是 base case，然后我们就可以穷举了：

1. 我们横着走吧，也就是对于 execution 中的每一个字母，都用 intention 的所有字母比一遍
2. 首先拿出 e，也就是 e 和 i、n、t、e、n、t、i、o、n 依次来比：
   - **一样的话就从左上角直接拿下来**
   - **不一样的话就取左、上、左上里最小值，加上 1，也就是加上自己那次变动**
3. 填完 e 那行，往下走，拿出 x 来比，直到比完

分析一下为啥这样比：

- **左边** 对应 `j-1`，也就是 **插入**
- **上边** 对应 `i-1`，也就是 **删除**
- **左上** 对应 `i-1, j-1`， 也就是 **跳过** 或者 **替换**，**记住虽然它俩都是看左上，但它俩是不同的状态**！！跳过没有 + 1，在 `if s1[i - 1] == s2[j - 1]:` 判断过了，替换是和上面两个操作同级的一个选择，所以有 + 1，在 `else` 里

总之和最长公共子序列类似，`dp[i][j]`都与相邻的值有关，慢慢从左上角推到右下角

### 解：

```python
def minDistance(s1, s2):
    dp = np.zeros((len(s1) + 1, len(s2) + 1), dtype=int)
    for i in range(1, len(s1) + 1):
        dp[i][0] = i
    for j in range(1, len(s2) + 1):
        dp[0][j] = j

    for i in range(1, len(s1) + 1):
        for j in range(1, len(s2) + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(
                    dp[i - 1][j] + 1,
                    dp[i][j - 1] + 1,
                    dp[i - 1][j - 1] + 1
                )
    return dp[len(s1)][len(s2)]
```



### 对比两个解法：

一个是从上到下，一个从下到上，啥意思呢？

- 自顶之下的递归是从尾部开始递归，直至 base case
- 而自底至上是从 base case 开始的迭代，直到遍历完最后一个字母
- 但要知道两个里面 base case 是不同的，一个类似于起点，而另一个类似于终点
- 方法二相对而言比较熟悉，因为和之前题目类似，但不管怎样，都要记住一点：**对于不同状态的不同选择，一定和 dp table 的邻居有关系，关系也就是状态转移方程，怎么找到的？数学归纳法，从 base case 开始推导**

