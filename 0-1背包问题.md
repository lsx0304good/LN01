## 01 背包问题



这题其实就是二维化的凑零钱问题，只不过对于代价有了一个限制，不再是无限次使用

`N = 3, W = 4, wt = [2, 1, 3], val = [4,2,3]`

只要画出了表，一切就都很容易了，首先对于最大重量来说，按照之前凑硬币问题的思路，我们要把 0 - W 所有重量所能带走的最大价值都穷举出来，然后对于每一个物品，我们再来比较要不要拿

- 状态：找变量，其实已经给了，N 和 W
- 选择：就两种选择，拿还是不拿
- base case: W 为 0 的时候，啥都拿不了，N 为 0 的时候，没东西可拿
- dp 数组：`dp[i][j]`表示的是对于前 `i` 个物品，重量限制为 `j` 的情况下，能够带走的最大价值

| i \ j |  0   |  1   |  2   |  3   |   4   |
| :---: | :--: | :--: | :--: | :--: | :---: |
|   0   |  0   |  0   |  0   |  0   |   0   |
|   1   |  0   |  0   |  4   |  4   |   4   |
|   2   |  0   |  2   |  4   |  6   |   6   |
|   3   |  0   |  2   |  4   |  6   | **9** |

*注意：*

- *`i ` 在这里表示的是前 `i` 个物品，并非第 `i` 个*
- *`i` 比`wt` 和 `val` 数组的索引多了 1，也就是多了前 0 个物品的情况，所以从数组中提取信息时需要 `i - 1`*

这里用 `dp[2][3]`举例，这时候有两种选择：拿还是不拿？

1. 不拿：不拿的话就是对于上一个物品的最终选择，所以 `dp[2][3] = dp[2-1][3] = 4`

2. 拿：我现在能装 3 kg，如果拿这个，我剩 `3 - wt[2-1]`kg，剩的这个重量能拿的最大价值是多少？去查 dp table：

   `dp[2-1][3-wt[2-1]]=4`，然后再加上我拿的这个：`dp[2-1][3-wt[2-1]]+val[2-1]=4+2=6`

由此可见，取较大值，该拿

那现在我们就有了状态转移方程：

```python
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - wt[i-1]] + val[i-1])
```

还有一个问题，我们得判断一下，假如这个物品装不下了怎么办？就不用再比了，直接继承上一个物品的最后选择就好，也就是：

```python
if j - wt[i-1] < 0: dp[i][j] = dp[i-1][j]
```

所以现在就可以进行dp table的代码化：

```python
import numpy as np
def knapsack(N, W, wt, val):
    dp = np.zeros((N + 1, W + 1), dtype=int)
    for i in range(1, N + 1):
        for j in range(1, W + 1):
            if j - wt[i-1] < 0:
                dp[i][j] = dp[i-1][j]
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - wt[i-1]] + val[i-1])
    return dp[N][W]
```