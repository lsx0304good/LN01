## 零钱兑换 II

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

示例：

输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/coin-change-2
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



### 思路：

这道题可以对比着之前的 [零钱兑换](https://github.com/lsx0304good/Algorithm-Learning-Notes/blob/main/LC322%20-%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.md) 一起看，之前要求的是 **凑成每个金额所需要的最少硬币数量**，这里是 **凑成每个金额的方法数量**

所以这个题也可以看做是一个完全背包问题

- 状态：目标金额，硬币面值，所以确定使用二维数组
- 选择：装还是不装？（根据是否能够凑到目标金额为判断依据）
- base case：凑 0 元时不需要硬币
- dp数组含义：`dp[i][j]`表示前 `i` 个硬币 凑出金额 `j` 的**方法数量**

然后想一下 dp table 怎么画出来，也就是得找一下状态转移方程：

1. 假如说我们在 `dp[2][4]`这个地方，这时候我们的情况是，拿出了 `coins[2-1]`面值也就是 2 元的硬币，考虑该不该拿
2. 这两个选择对应的情况就是，如果不拿的话， 那`dp[2][4]`的值就是之前继承下来的次数，也就是没有用这个面值的硬币就凑成了目标面额的次数 `dp[1][4]`，再加上使用了这枚硬币凑成目标金额的次数，也就是目标金额减去这个硬币面值时，所拥有的最多次数，也就是 `dp[2][4-coins[1]]`
3. 把 2 说的白话一点，就是想用面值为 2 的硬币凑出 5，如果知道了凑 3 的方法，再加上这个 2 元，就凑成 5 了。但是要注意，**我们统计的是次数，而不是硬币数量，所以不需要做任何次数上 + 1**

|      | 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 0    | 0    | 0    | 0    | 0    |
| 1    | 1    | 1    | 1    | 1    | 1    | 1    |
| 2    | 1    | 1    | 2    | 2    | 3    | 3    |
| 3    | 1    | 1    | 2    | 2    | 3    | 4    |



```python
def change(amount, coins):
    dp = np.zeros((len(coins) + 1, amount + 1), dtype=int)
    for row in dp:
        row[0] = 1
    for i in range(1, len(coins) + 1):
        for j in range(1, amount + 1):
            if j - coins[i - 1] < 0:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]
    return dp[len(coins)][amount]
```
