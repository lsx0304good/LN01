### 第一步：根据题目，首先搭建伪代码框架：

- coins: 包含不同面值硬币的列表
- amount: 需要凑出的面值

```python
def coinChange(coins, amount):
    def dp(n):
        for coin in coins:
            res = min(res, 1 + dp(n - coin))
        return res
    return dp(amount)
```

1. `dp(n)`: 凑出金额 n 所需要的 **硬币数量**
2. `dp(n - coin)`: 除了这枚之外 **还需要多少枚**
3. `1 + dp(n - coin)`: 每个结果都比上一个结果 **多需要一枚**
4. `min(res, 1 + dp(n - coin))`: 选择需要硬币 **最少的** 那个结果

### 第二步：思考  Base Case：

- 递归的终点，当金额到达 **0** 时，不再需要硬币即可得到答案
- 无解的情况，金额 **不可能达到负值**
- 所谓动态规划，是指对于变化的值使用函数计算出相应的结果，这里变化的值是 n ，也就是需要凑的金额，在这里要考虑的是金额的三种状态：**0，负，正常。**
- 为 **0** 的时候可取，表示正好凑到，所以参与最小值的选择
- 然而为 **-1** 时不可取，表示 **凑出的金额溢出了**，所以有`if subproblem == -1:`这个条件句，来 **丢弃造成溢出的步骤**
- `for coin in coins:`**对于每一种面值，我们可以取无数次**，所以对每一种面值进行递归，直到取到目标金额
- res 是穷举了所有可能的结果后**最小的结果**

```python
def coinChange(coins, amount):
    def dp(n):
        # base case
        if n == 0:
            return 0
        if n < 0:
            return -1
        # 求最小值，初始为无穷大
        res = float('INF')
        for coin in coins:
            subproblem = dp(n - coin)
            if subproblem == -1:
                continue
            res = min(res, 1 + subproblem)
        return res if res != float('INF') else -1

    return dp(amount)
```

