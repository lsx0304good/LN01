## 最长回文子序列

给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-palindromic-subsequence
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 思路：

看见**最长**，**子序列** 这俩关键词，就直接走动态规划了

我们得定义一下 dp 数组的含义：这里我们选择二维数组，因为一维数组适用于数学归纳法，这里不能明确使用归纳法计算，所以我们要的是二维 `dp[i][j]`，然后考虑一下 `i` 和 `j` 是什么，很明显是分别指向两个字母，之前的题是对于两个字符串，这里可以理解为两个相同的字符串；题目要求的是最长回文子序列，这样就简单了，我们让 **`dp[i][j]`表示 字符串`i`到`j`区间的最长回文子序列**，那我们肯定要求的就是`i`在最左，`j`在最右时候的情况；现在推导一下，假如我们要求 `dp[i][j]`的值，它上一步是什么呢，因为最终是`i`在最左，`j`在最右，那么上一步肯定是`i`右移动，`j`左移动，也就是 `dp[i+1][j-1]`的值，然后呢？现在有两个状态，可以考虑一下：

- 状态 1：`s[i] == s[j]`，这时候两个字母相同，那就有了`dp[i][j] == dp[i+1][j-1] + 2`，也就是 **之前最长的回文子序列再加了两个字母**
- 状态 2：`s[i] != s[j]`，这时候咋办，不加呗，那值取谁？**`dp[i+1][j-1]`走到 `dp[i][j]` 实际上有两种情况**：
  - 情况 1：`dp[i][j-1]`，`i`先动了，`j`没动，这里存了一个回文子序列长度
  - 情况 2：`dp[i-1][j]`，反过来，这里也存了一个长度
  - 那我们是不是得比较一下？所以我们取一个最大的：`max(情况1，情况2)`

先画个基础表吧：

|       | j = 0 | j =1 | j =2 | j =3 | j =4 |
| :---: | :---: | :--: | :--: | :--: | :--: |
| i = 0 |   1   |      |      |      |      |
| i = 1 |   0   |  1   |      |      |      |
| i = 2 |   0   |  0   |  1   |      |      |
| i = 3 |   0   |  0   |  0   |  1   |      |
| i = 4 |   0   |  0   |  0   |  0   |  1   |

- 首先 `i` 和 `j`都是对于同一个字符串的索引，所以当 `i = j`的时候，代表的是同一个字母，对于同一个字母，那最长回文子序列肯定是 1，也就是它自己，所以左上到右下斜着全是 1
- 为啥左下方都是 0 呢？因为在这个方法中， `i` 在左边，`j` 在右边，`i`应该小于`j`，乘法口诀表知道吧，要一半就够了，另一半是重复的，没用

**现在要的是二维的想法，抛弃`i`和`j`遍历的画面，盯着表看**，我们把之前说的总结一下，就知道怎么填表了：

- `s[i] == s[j]`：`dp[i][j] == dp[i+1][j-1] + 2` （直接取左下角的值然后 + 2）
- `s[i] != s[j]`：`max(dp[i][j-1], dp[i-1][j])` （取左和下里面较大的）

那从哪开始填？我们知道这种方法需要的是左、下和左下三个格子，所以我们肯定贴着 1 的那个斜边开始，所以首选是从 `dp[3][4]`开始，然后 `i`递减，也就是左移，对于每个不同的 `i`，`j`来递增，也就是右移（**有一种从下往上，从左往右刷墙的感觉**）：

|      |  b   |  b   |  b   |  a   |       b        |
| :--: | :--: | :--: | :--: | :--: | :------------: |
|  b   |  1   |  2   |  3   |  3   | ***<u>4</u>*** |
|  b   |  0   |  1   |  2   |  2   |       3        |
|  b   |  0   |  0   |  1   |  1   |       3        |
|  a   |  0   |  0   |  0   |  1   |       1        |
|  b   |  0   |  0   |  0   |  0   |       1        |

所以我们很容易就能写出代码：

```python
def longestPalindromeSubseq(s):
    n = len(s)
    dp = np.zeros((n, n), dtype=int)
    for i in range(n):
        dp[i][i] = 1
	
    for i in range(n-2,-1,-1):  # i from R to L
        for j in range(i+1, n):  # j from L to R for each i
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    return dp[0][n-1]
```



### 总结：

做这个题时候有两个难点：

1. 思考一下 dp 数组的定义，为什么是二维，`i`和`j`分别代表什么
2. **不要一直盯着`i`和`j`，既然有了二维表，就从表中寻找算法**

