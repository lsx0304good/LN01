## 鸡蛋掉落

你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/super-egg-drop
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



### 问题简化

- K 个鸡蛋，N 层楼，鸡蛋没碎可以继续用
- **最坏情况** 的 **最少次数**



## 方法一：动态规划

虽然是求最值，但这里是两个最值，我们先要求最坏情况，然后再从里面挑出最少次数；这里其实很容易去定义 dp 函数的含义，`dp(K, N)`，**表示的是用 K 个鸡蛋，面对 N 层楼，所用的最少试验次数**。

- 从 base case 开始推，假如我们就一个鸡蛋，也就是 `K = 1`，这样我们最坏情况就是从一层直到楼顶才碎，线性增长，所以 `dp(K, N) = N`
- 如果这个楼层本身就是 0 呢？那根本就不用扔，也就是`N = 0`的时候，`dp(K, N) = 0`

接下来分析状态转移：

- 鸡蛋只可能有两种情况，碎和没碎，关键在于碎了之后怎么去做
  - 如果碎了：那毫无疑问需要`K - 1`，然后我们就要往低楼层测试，因为往上肯定都碎，假如我们从一层开始，走到了`i`层，蛋碎了，那这时候我们的选择就是`dp(K - 1, i - 1)`，举个例子，我们10层楼顶不住，就去测9层楼，然后这时候我们还损失了一个蛋
  - 如果没碎：那我们可以接着用这个鸡蛋，这时候 K 保持原来的数量，然后我们得往高走，`i`层不碎，那就试试`i+1 到 N`层，注意这里，我们函数中要的 N 不是第几层，而是面对的是多少层，假如你是 11 层到 20 层，这里 N 是 **20 - 11 = 9** 而不是 11；所以我们就有了`dp(K, N - i)`
  - 然后我们是不是在`i`层扔的？所以这也算是一次测试，所以前面两种情况都要 + 1

上述的两种选择有了，题目中我们需要的是最坏情况的最少次数，所以在作出不同选择后，我们就可以得到最坏情况，也就是`max(dp(K - 1, i - 1), dp(K, N - i)) + 1`，然后再取最少次数，那肯定是遍历完 1 到 N 层之后选出的最小值，所以用迭代来求就可以了

然后就可以完成代码：

```python
def superEggDrop(K, N):
    memo = dict()
    def dp(K, N):
        if N == 0:
            return 0
        if M == 1:
            return N
        if (K, N) in memo:
            return memo[(K, N)]
        
        res = float("INF")
        for i in range(1, N + 1):
            res = min(res, max(
                dp(K - 1, i - 1),
                dp(K, N - i)
            ) + 1)
        memo[(K, N)] = res
        return res
    return dp(K, N)
```

这里使用`memo`来剪枝，不然楼层高了之后算的非常慢

注意：这个方法在 LC 上面会超时，因为时间复杂度为 O(KN^2)，所以我们想到了下一个方法，使用二分法优化遍历过程，不再是`for loop`遍历



## 方法一优化：二分搜索优化

在方法一里，我们使用`i`逐层遍历消耗大量时间内存，所以可以想到用二分搜索来优化遍历过程；但是这里又很难想，因为涉及到了函数的单调性

首先还是用上述代码的基本框架来思考：

```python
def dp(K, N):
    for i in range(1, N + 1):
        res = min(res, max(
            dp(K - 1, i - 1),
            dp(K, N - i)
        ) + 1)
    return res
```

用碎和没碎两种选择进行递归，这就是核心的状态转移方程，但下面是比较难思考到的：

- 用数学思想来考虑一下能发现这个 dp 函数是线性的，假如给了你 K 个鸡蛋，那在 K 不变的情况下，你测试的次数是随着楼层 N 的增加而单调递增的：

  1. 对于 `dp(K - 1, i - 1)`来说：`i`越大，那返回结果也就是测试数量就越大

  2. 对于`dp(K, N - i)`来说：`i`越大，那`N - i`就越小，也就是你面对的楼层数越来越小，那测试数量也就减小

- 所以这两种选择就变成了两个单调性相反的函数，随着 **所在楼层`i`的增加，1 单调递增，2 单调递减**

所以我们就有了一个 X 形状的图像，`x` 轴为 `i`，`y` 轴为测试次数，那就很容易观察到，因为我们要取最坏情况，也就是`x`轴相同时，两者比较大的那个，这样我们就得到了 V 形状的图像，然后再挑出最少次数，也就是 V 的底端，说白了就是 **两个函数的交点**

这样就可以优化代码：

```python
def superEggDrop(self, K: int, N: int) -> int:
        memo = dict()
        def dp(K, N):
            if K == 1:
                return N
            if N == 0:
                return 0

            if (K, N) in memo:
                return memo[(K, N)]
            
            res = float("INF")
            
            # binary search starts here
            lo = 1
            hi = N
            while lo <= hi:
                mid = (lo + hi) // 2  # we start from mid
                broken = dp(K - 1, mid - 1)
                not_broken = dp(K, N - mid)

                if broken > not_broken:
                    hi = mid - 1
                    res = min(res, broken + 1)
                else:
                    lo = mid + 1
                    res = min(res, not_broken + 1)
            memo[(K, N)] = res
            return res

        return dp(K, N)
```

这里解释下面这几行：

- `broken = dp(K - 1, mid - 1)`：如果蛋碎了，那我们这时候区间变为整个楼的下半部分，也就是 一层到`mid-1`层，总楼层数 `mid - 1`

- `not_broken = dp(K, N - mid)`：如果没碎，那我们区间变成整个楼的上半部分，也就是 `mid+1`层到 N 层，总楼层数 `N - mid`

- ```python
  if broken > not_broken:
      hi = mid - 1
      res = min(res, broken + 1)
  else:
      lo = mid + 1
      res = min(res, not_broken + 1)
  ```

  这里我们要记得，我们要的是 V 字形的最低点，所以当`broken > not_broken`，说明我们在 V 字形的右半部分，要往左进行二分，所以 `hi = mid - 1`，反之

这里一定要结合理解我们两个选择所用的`mid`和函数图像里的`mid`，`mid`代表的是当前测试时所在的楼层，也就是`i`，也就是我们的自变量，在不同选择(两个函数)的影响下，寻找它们的交点。



## 方法二：重定义状态转移

使用不同的出发点来重新思考这个问题：

- K 个鸡蛋，N 层楼，鸡蛋没碎可以继续用
- **最坏情况** 的 **最少次数**

如果我们用 dp 数组来定义一下，原本是求 K 个鸡蛋，面对 N 层，最少多少次确定蛋不碎；那意思也就是：**给你 K 个鸡蛋，你可以试 M 次，最后告诉我这个蛋能经得住多少层**。那有了这个 dp table，我们要找到测 n 层最少要多少次，不就是把这个索引位置的 M 拿出来么

现在只需要继续记住之前的哪两个选择：

1. 蛋碎了向下走，不碎向上走
2. 总楼数 = 下层数 + 上层数 + 1 （当前层）

状态转移方程：

`dp[K][M] = dp[K-1][M-1] + dp[K][M-1] + 1`，你一共有 M 次试的机会，试完一次，不管蛋碎没碎，都得`M-1`

然后就很容易了：

```python
import numpy as np
def superEggDrop(K, N):
    dp = np.zeros((K+1,N+1), dtype=int)
    m = 0

    while dp[K][m] < N:
        m += 1
        for k in range(1, K + 1):
            dp[k][m] = dp[k-1][m-1] + dp[k][m-1] + 1
    return m
```

