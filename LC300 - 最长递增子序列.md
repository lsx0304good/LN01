## 最长递增子序列

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：

输入：`nums = [10,9,2,5,3,7,101,18]`
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

输入：`nums = [0,1,0,3,2,3]`
输出：4
示例 3：

输入：`nums = [7,7,7,7,7,7,7]`
输出：1

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-increasing-subsequence
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 解：

动态规划问题也就是数学归纳问题，我们从 **base case** 开始下手归纳：

- 从索引 0 开始，因为这是第一个元素，所以它最长递增子序列一定是自己，长度一定为 1

- 到了 1，我们肯定要用它与前面的作比较呀，如果它比前面大，长度自然在前一个基础上 + 1；如果比前面小，那么就也是它自己，长度为 1；这里 9 比 10 小，不可能排成递增子序列，所以 9 的最长递增子序列长度也是 1

- 到了 2，值为 2，同样，但这次得比两次， 跟索引 0 也就是 10 比一次，再和索引 1 也就是 9 比一次，发现比它俩都小，所以对于 2，它最长递增子序列也是自己，长度为 1

- 到了 3，对应值为 5，我们还是检查它之前的所有，发现 索引 2 的值是 2，比它小，这时候我们就有了递增子序列[2,5]，长度为 2；那么 2 是怎么来的，**不是数出来的，是用 索引 2 的最长递增子序列长度加上了 1，这个 1 就是我们的 5** 

- 以此类推，当我们走到 索引 5，对应的值为 7 时，我们就有了 **选择**，对于 7 来说，前面的 2, 5 和 3 都比它小，那我们该选哪个？

  1. 如果选 2，它的最长递增子序列长度为 1: `[2]`
  2. 如果选 5，它的最长递增子序列长度为 2: `[2, 5]`
  3. 如果选 3，它的最长递增子序列长度也为 2: `[2, 3]`

  肉眼观察，肯定是选后两个，因为要最长嘛；所以现在脑子里应该有一个方法来自动选择最长了，也就是在 for loop 中遍历所有满足情况的选择，`当前的次数 = max(当前次数, 每个选择 + 1)` 更新出最长的那个，至于为什么每个选择 + 1，就是要算上它自己本身

根据这个思路，我们可以直接完成：

```python
def lengthOfLIS(nums):
    dp = []
    for _ in range(len(nums)):
        dp.append(1)
    for i in range(len(nums)):
        for j in range(0, i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)             
    return max(dp)
```

dp 数组中，我们就有了每个值的最长递增子序列长度，再取最大的那个即可